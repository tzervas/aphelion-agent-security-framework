[
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Awaitable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "JWTConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "AppConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "AppConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "JWTConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "AppConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "JWTConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "AppConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "JWTConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "LoggingConfigModel",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG_FILE",
        "importPath": "aphelion.config",
        "description": "aphelion.config",
        "isExtraImport": true,
        "detail": "aphelion.config",
        "documentation": {}
    },
    {
        "label": "casbin",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "casbin",
        "description": "casbin",
        "detail": "casbin",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "starlette.requests",
        "description": "starlette.requests",
        "isExtraImport": true,
        "detail": "starlette.requests",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "HTTPBearer",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "HTTPAuthorizationCredentials",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "BaseHTTPMiddleware",
        "importPath": "starlette.middleware.base",
        "description": "starlette.middleware.base",
        "isExtraImport": true,
        "detail": "starlette.middleware.base",
        "documentation": {}
    },
    {
        "label": "ASGIApp",
        "importPath": "starlette.types",
        "description": "starlette.types",
        "isExtraImport": true,
        "detail": "starlette.types",
        "documentation": {}
    },
    {
        "label": "ASGIApp",
        "importPath": "starlette.types",
        "description": "starlette.types",
        "isExtraImport": true,
        "detail": "starlette.types",
        "documentation": {}
    },
    {
        "label": "validate_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "InvalidTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "ExpiredTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "MissingTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "create_refresh_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "decode_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "validate_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "# JWTConfig",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "# This is now JWTConfigModel from aphelion.config\r\n    # configure_jwt",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "# This is removed\r\n    InvalidTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "ExpiredTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "MissingTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "RevokedTokenError",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "revoke_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "is_token_revoked",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "clear_revoked_tokens_store # New helper for test cleanup\r\n    # _jwt_config",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "importPath": "aphelion.auth.jwt",
        "description": "aphelion.auth.jwt",
        "isExtraImport": true,
        "detail": "aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "SecretStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "SecretStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "SettingsConfigDict",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "init_enforcer",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "get_enforcer",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "enforce",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "PolicyError",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "NotAuthorizedError",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "# Will test this if enforce is modified to raise it\r\n    DEFAULT_MODEL_PATH",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POLICY_PATH",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "_enforcer",
        "importPath": "aphelion.authz.casbin_enforcer",
        "description": "aphelion.authz.casbin_enforcer",
        "isExtraImport": true,
        "detail": "aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "AsyncClient",
        "importPath": "httpx",
        "description": "httpx",
        "isExtraImport": true,
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "AphelionFastAPIMiddleware",
        "importPath": "aphelion.frameworks.fastapi.middleware",
        "description": "aphelion.frameworks.fastapi.middleware",
        "isExtraImport": true,
        "detail": "aphelion.frameworks.fastapi.middleware",
        "documentation": {}
    },
    {
        "label": "get_current_subject",
        "importPath": "aphelion.frameworks.fastapi.middleware",
        "description": "aphelion.frameworks.fastapi.middleware",
        "isExtraImport": true,
        "detail": "aphelion.frameworks.fastapi.middleware",
        "documentation": {}
    },
    {
        "label": "pytest_asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest_asyncio",
        "description": "pytest_asyncio",
        "detail": "pytest_asyncio",
        "documentation": {}
    },
    {
        "label": "given",
        "importPath": "hypothesis",
        "description": "hypothesis",
        "isExtraImport": true,
        "detail": "hypothesis",
        "documentation": {}
    },
    {
        "label": "strategies",
        "importPath": "hypothesis",
        "description": "hypothesis",
        "isExtraImport": true,
        "detail": "hypothesis",
        "documentation": {}
    },
    {
        "label": "settings",
        "importPath": "hypothesis",
        "description": "hypothesis",
        "isExtraImport": true,
        "detail": "hypothesis",
        "documentation": {}
    },
    {
        "label": "HealthCheck",
        "importPath": "hypothesis",
        "description": "hypothesis",
        "isExtraImport": true,
        "detail": "hypothesis",
        "documentation": {}
    },
    {
        "label": "get_greeting",
        "importPath": "aphelion.main",
        "description": "aphelion.main",
        "isExtraImport": true,
        "detail": "aphelion.main",
        "documentation": {}
    },
    {
        "label": "MissingTokenError",
        "kind": 6,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "class MissingTokenError(Exception):\n    \"\"\"Raised when a token is expected but not found.\"\"\"\n    pass\nclass InvalidTokenError(Exception):\n    \"\"\"Raised when a token is invalid (e.g., malformed, wrong signature).\"\"\"\n    pass\nclass ExpiredTokenError(InvalidTokenError):\n    \"\"\"Raised when a token has expired.\"\"\"\n    pass\nclass RevokedTokenError(InvalidTokenError):",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "InvalidTokenError",
        "kind": 6,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "class InvalidTokenError(Exception):\n    \"\"\"Raised when a token is invalid (e.g., malformed, wrong signature).\"\"\"\n    pass\nclass ExpiredTokenError(InvalidTokenError):\n    \"\"\"Raised when a token has expired.\"\"\"\n    pass\nclass RevokedTokenError(InvalidTokenError):\n    \"\"\"Raised when a token has been revoked.\"\"\"\n    pass\n# --- Token Creation ---",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "ExpiredTokenError",
        "kind": 6,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "class ExpiredTokenError(InvalidTokenError):\n    \"\"\"Raised when a token has expired.\"\"\"\n    pass\nclass RevokedTokenError(InvalidTokenError):\n    \"\"\"Raised when a token has been revoked.\"\"\"\n    pass\n# --- Token Creation ---\ndef _create_token(\n    data: Dict[str, Any],\n    expires_delta: timedelta,",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "RevokedTokenError",
        "kind": 6,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "class RevokedTokenError(InvalidTokenError):\n    \"\"\"Raised when a token has been revoked.\"\"\"\n    pass\n# --- Token Creation ---\ndef _create_token(\n    data: Dict[str, Any],\n    expires_delta: timedelta,\n    token_type: str = \"access\"\n) -> str:\n    \"\"\"",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def create_access_token(subject: Union[str, Any], additional_claims: Optional[Dict[str, Any]] = None) -> str:\n    \"\"\"\n    Creates an access token.\n    :param subject: Identifier for the token subject (e.g., user ID, agent ID).\n    :param additional_claims: Optional dictionary of additional claims to include.\n    :return: Encoded JWT string.\n    \"\"\"\n    if additional_claims is None:\n        additional_claims = {}\n    jwt_cfg = get_config().jwt",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "create_refresh_token",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def create_refresh_token(subject: Union[str, Any]) -> str:\n    \"\"\"\n    Creates a refresh token.\n    :param subject: Identifier for the token subject (e.g., user ID, agent ID).\n    :return: Encoded JWT string.\n    \"\"\"\n    jwt_cfg = get_config().jwt\n    expires_delta = timedelta(days=jwt_cfg.refresh_token_expire_days)\n    data_to_encode = {\"sub\": str(subject)}\n    # Refresh tokens typically have fewer claims and longer expiry",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "decode_token",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def decode_token(token: str) -> Dict[str, Any]:\n    \"\"\"\n    Decodes a JWT.\n    Raises InvalidTokenError or ExpiredTokenError on failure.\n    :param token: The JWT string to decode.\n    :return: The decoded payload as a dictionary.\n    :raises MissingTokenError: If the token is None or empty.\n    :raises ExpiredTokenError: If the token has expired.\n    :raises InvalidTokenError: If the token is malformed, has an invalid signature, or other JWT errors.\n    :raises RevokedTokenError: If the token is in the revocation list.",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "validate_token",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def validate_token(token: str, expected_token_type: Optional[str] = \"access\") -> Dict[str, Any]:\n    \"\"\"\n    Validates a token and checks its type.\n    :param token: The JWT string to validate.\n    :param expected_token_type: The expected type of the token (e.g., \"access\", \"refresh\").\n                                If None, type check is skipped.\n    :return: The decoded payload if the token is valid.\n    :raises InvalidTokenError: If the token type does not match or other validation issues.\n    \"\"\"\n    payload = decode_token(token) # This already handles expiry, signature, etc.",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "revoke_token",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def revoke_token(token_jti_or_full_token: str) -> None:\n    \"\"\"\n    Adds a token's JTI (JWT ID) or the full token string to the in-memory revocation list.\n    NOTE: This is a very basic in-memory revocation. Not suitable for production\n    without a persistent and shared revocation list (e.g., Redis, database).\n    \"\"\"\n    _revoked_tokens_store.add(token_jti_or_full_token)\ndef is_token_revoked(token_jti_or_full_token: str) -> bool:\n    \"\"\"Checks if a token (by JTI or full string) is in the in-memory revocation list.\"\"\"\n    return token_jti_or_full_token in _revoked_tokens_store",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "is_token_revoked",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def is_token_revoked(token_jti_or_full_token: str) -> bool:\n    \"\"\"Checks if a token (by JTI or full string) is in the in-memory revocation list.\"\"\"\n    return token_jti_or_full_token in _revoked_tokens_store\ndef clear_revoked_tokens_store() -> None:\n    \"\"\"Clears all tokens from the in-memory revocation list. Useful for testing.\"\"\"\n    _revoked_tokens_store.clear()\nif __name__ == \"__main__\":\n    # Basic usage example (primarily for quick testing during development)\n    # This will use the configuration loading mechanism (dummy files created in config.py's main)\n    # Ensure config is loaded (normally happens on first get_config() call)",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "clear_revoked_tokens_store",
        "kind": 2,
        "importPath": "src.aphelion.auth.jwt",
        "description": "src.aphelion.auth.jwt",
        "peekOfCode": "def clear_revoked_tokens_store() -> None:\n    \"\"\"Clears all tokens from the in-memory revocation list. Useful for testing.\"\"\"\n    _revoked_tokens_store.clear()\nif __name__ == \"__main__\":\n    # Basic usage example (primarily for quick testing during development)\n    # This will use the configuration loading mechanism (dummy files created in config.py's main)\n    # Ensure config is loaded (normally happens on first get_config() call)\n    # For this main block, let's explicitly load a test config if needed,\n    # or rely on the default loading mechanism.\n    # For jwt.py's own __main__, it's better if it can run somewhat independently",
        "detail": "src.aphelion.auth.jwt",
        "documentation": {}
    },
    {
        "label": "PolicyError",
        "kind": 6,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "class PolicyError(Exception):\n    \"\"\"Raised for issues related to policy loading or model errors.\"\"\"\n    pass\nclass AuthorizationError(Exception):\n    \"\"\"Base class for authorization failures.\"\"\"\n    pass\nclass NotAuthorizedError(AuthorizationError):\n    \"\"\"Raised when a subject is not authorized for a specific action on an object.\"\"\"\n    def __init__(self, subject: Any, obj: Any, action: Any, message: Optional[str] = None):\n        self.subject = subject",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "AuthorizationError",
        "kind": 6,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "class AuthorizationError(Exception):\n    \"\"\"Base class for authorization failures.\"\"\"\n    pass\nclass NotAuthorizedError(AuthorizationError):\n    \"\"\"Raised when a subject is not authorized for a specific action on an object.\"\"\"\n    def __init__(self, subject: Any, obj: Any, action: Any, message: Optional[str] = None):\n        self.subject = subject\n        self.obj = obj\n        self.action = action\n        if message is None:",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "NotAuthorizedError",
        "kind": 6,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "class NotAuthorizedError(AuthorizationError):\n    \"\"\"Raised when a subject is not authorized for a specific action on an object.\"\"\"\n    def __init__(self, subject: Any, obj: Any, action: Any, message: Optional[str] = None):\n        self.subject = subject\n        self.obj = obj\n        self.action = action\n        if message is None:\n            message = f\"Subject '{subject}' is not authorized to '{action}' on object '{obj}'.\"\n        super().__init__(message)\n# --- Enforcer Initialization and Access ---",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "init_enforcer",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def init_enforcer(\n    model_path: Optional[Union[str, Path]] = None,\n    policy_adapter: Optional[Union[str, Path, object]] = None\n) -> casbin.Enforcer:\n    \"\"\"\n    Initializes and returns a Casbin enforcer instance.\n    If an enforcer is already initialized, it returns the existing one unless paths are different.\n    This function should ideally be called once at application startup.\n    :param model_path: Path to the Casbin model configuration file (.conf).\n                       Defaults to DEFAULT_MODEL_PATH.",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "get_enforcer",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def get_enforcer() -> casbin.Enforcer:\n    \"\"\"\n    Retrieves the global Casbin enforcer instance.\n    Initializes it with default paths if it hasn't been initialized yet.\n    :return: The global Casbin Enforcer instance.\n    :raises PolicyError: If the enforcer is not initialized and fails to initialize.\n    \"\"\"\n    if _enforcer is None:\n        # Attempt to initialize with defaults or paths from config if available\n        # app_cfg = get_config()",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "enforce",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def enforce(subject: Any, obj: Any, action: Any) -> bool:\n    \"\"\"\n    Performs an authorization check using the Casbin enforcer.\n    :param subject: The subject (e.g., user ID, role name) requesting access.\n    :param obj: The object (e.g., resource name, data entity) being accessed.\n    :param action: The action (e.g., read, write, execute) being performed.\n    :return: True if authorized, False otherwise.\n    :raises PolicyError: If the enforcer is not initialized.\n    \"\"\"\n    enforcer = get_enforcer()",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "add_policy_rule",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def add_policy_rule(subject: Any, obj: Any, action: Any) -> bool:\n    \"\"\"\n    Adds a single policy rule to the current Casbin enforcer.\n    Example: add_policy_rule(\"user1\", \"data1\", \"read\")\n    Note: This modifies the in-memory policy. Call save_policy_to_file() to persist if using FileAdapter.\n    \"\"\"\n    enforcer = get_enforcer()\n    # Casbin's add_policy expects variadic string arguments, not a list.\n    # For ptype 'p', it's typically (sub, obj, act)\n    # For gtype 'g', it's typically (user, role, optional_domain)",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "remove_policy_rule",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def remove_policy_rule(subject: Any, obj: Any, action: Any) -> bool:\n    \"\"\"\n    Removes a single policy rule from the current Casbin enforcer.\n    Note: This modifies the in-memory policy. Call save_policy_to_file() to persist if using FileAdapter.\n    \"\"\"\n    enforcer = get_enforcer()\n    return enforcer.remove_policy(str(subject), str(obj), str(action))\ndef add_grouping_policy_rule(user: Any, role: Any, domain: Optional[str] = None) -> bool:\n    \"\"\"\n    Adds a role assignment (grouping policy).",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "add_grouping_policy_rule",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def add_grouping_policy_rule(user: Any, role: Any, domain: Optional[str] = None) -> bool:\n    \"\"\"\n    Adds a role assignment (grouping policy).\n    Example: add_grouping_policy_rule(\"alice\", \"admin\")\n    Note: This modifies the in-memory policy. Call save_policy_to_file() to persist.\n    \"\"\"\n    enforcer = get_enforcer()\n    if domain:\n        return enforcer.add_grouping_policy(str(user), str(role), str(domain))\n    return enforcer.add_grouping_policy(str(user), str(role))",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "remove_grouping_policy_rule",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def remove_grouping_policy_rule(user: Any, role: Any, domain: Optional[str] = None) -> bool:\n    \"\"\"\n    Removes a role assignment (grouping policy).\n    Note: This modifies the in-memory policy. Call save_policy_to_file() to persist.\n    \"\"\"\n    enforcer = get_enforcer()\n    if domain:\n        return enforcer.remove_grouping_policy(str(user), str(role), str(domain))\n    return enforcer.remove_grouping_policy(str(user), str(role))\ndef get_all_policy_rules() -> list[list[str]]:",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "get_all_policy_rules",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def get_all_policy_rules() -> list[list[str]]:\n    \"\"\"Returns all policy rules from the enforcer.\"\"\"\n    enforcer = get_enforcer()\n    return enforcer.get_policy()\ndef get_all_grouping_policy_rules() -> list[list[str]]:\n    \"\"\"Returns all grouping policy rules (role assignments) from the enforcer.\"\"\"\n    enforcer = get_enforcer()\n    return enforcer.get_grouping_policy()\ndef save_policy_to_file() -> bool:\n    \"\"\"",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "get_all_grouping_policy_rules",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def get_all_grouping_policy_rules() -> list[list[str]]:\n    \"\"\"Returns all grouping policy rules (role assignments) from the enforcer.\"\"\"\n    enforcer = get_enforcer()\n    return enforcer.get_grouping_policy()\ndef save_policy_to_file() -> bool:\n    \"\"\"\n    Saves the current in-memory policy back to the policy file\n    if the adapter supports it (e.g., FileAdapter).\n    This is a no-op for adapters that auto-save or don't use files.\n    Returns True if save was attempted (actual success depends on adapter).",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "save_policy_to_file",
        "kind": 2,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "def save_policy_to_file() -> bool:\n    \"\"\"\n    Saves the current in-memory policy back to the policy file\n    if the adapter supports it (e.g., FileAdapter).\n    This is a no-op for adapters that auto-save or don't use files.\n    Returns True if save was attempted (actual success depends on adapter).\n    \"\"\"\n    enforcer = get_enforcer()\n    # The save_policy method is part of the Adapter API that the Enforcer can call.\n    # Casbin's FileAdapter implements save_policy.",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "CONFIG_BASE_DIR",
        "kind": 5,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "CONFIG_BASE_DIR = Path(__file__).resolve().parent.parent.parent / \"config\"\nDEFAULT_MODEL_PATH = CONFIG_BASE_DIR / \"rbac_model.conf\"\nDEFAULT_POLICY_PATH = CONFIG_BASE_DIR / \"rbac_policy.csv\"\n# --- Global Enforcer Instance ---\n_enforcer: Optional[casbin.Enforcer] = None\n# --- Custom Exceptions ---\nclass PolicyError(Exception):\n    \"\"\"Raised for issues related to policy loading or model errors.\"\"\"\n    pass\nclass AuthorizationError(Exception):",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MODEL_PATH",
        "kind": 5,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "DEFAULT_MODEL_PATH = CONFIG_BASE_DIR / \"rbac_model.conf\"\nDEFAULT_POLICY_PATH = CONFIG_BASE_DIR / \"rbac_policy.csv\"\n# --- Global Enforcer Instance ---\n_enforcer: Optional[casbin.Enforcer] = None\n# --- Custom Exceptions ---\nclass PolicyError(Exception):\n    \"\"\"Raised for issues related to policy loading or model errors.\"\"\"\n    pass\nclass AuthorizationError(Exception):\n    \"\"\"Base class for authorization failures.\"\"\"",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POLICY_PATH",
        "kind": 5,
        "importPath": "src.aphelion.authz.casbin_enforcer",
        "description": "src.aphelion.authz.casbin_enforcer",
        "peekOfCode": "DEFAULT_POLICY_PATH = CONFIG_BASE_DIR / \"rbac_policy.csv\"\n# --- Global Enforcer Instance ---\n_enforcer: Optional[casbin.Enforcer] = None\n# --- Custom Exceptions ---\nclass PolicyError(Exception):\n    \"\"\"Raised for issues related to policy loading or model errors.\"\"\"\n    pass\nclass AuthorizationError(Exception):\n    \"\"\"Base class for authorization failures.\"\"\"\n    pass",
        "detail": "src.aphelion.authz.casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "AphelionFastAPIMiddleware",
        "kind": 6,
        "importPath": "src.aphelion.frameworks.fastapi.middleware",
        "description": "src.aphelion.frameworks.fastapi.middleware",
        "peekOfCode": "class AphelionFastAPIMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    FastAPI middleware for Aphelion security.\n    Handles JWT authentication. Authorization can be added later or handled by dependencies.\n    \"\"\"\n    def __init__(\n        self,\n        app: ASGIApp,\n        public_paths: Optional[set[str]] = None, # Paths that do not require authentication\n        # authz_enforcer: Optional[Callable] = None # Placeholder for Casbin enforcer integration",
        "detail": "src.aphelion.frameworks.fastapi.middleware",
        "documentation": {}
    },
    {
        "label": "bearer_scheme",
        "kind": 5,
        "importPath": "src.aphelion.frameworks.fastapi.middleware",
        "description": "src.aphelion.frameworks.fastapi.middleware",
        "peekOfCode": "bearer_scheme = HTTPBearer(auto_error=False) # auto_error=False to handle errors in middleware\n# --- Subject Retriever for Path Operations ---\nasync def get_current_subject(request: Request) -> Any:\n    \"\"\"\n    FastAPI dependency to get the authenticated subject from request.state.\n    This should be used in path operations that are protected by the middleware.\n    Returns the subject (e.g., user_id) if authentication was successful.\n    Raises HTTPException if the subject is not available (shouldn't happen if middleware is effective).\n    \"\"\"\n    if not hasattr(request.state, \"subject\") or request.state.subject is None:",
        "detail": "src.aphelion.frameworks.fastapi.middleware",
        "documentation": {}
    },
    {
        "label": "JWTConfigModel",
        "kind": 6,
        "importPath": "src.aphelion.config",
        "description": "src.aphelion.config",
        "peekOfCode": "class JWTConfigModel(BaseModel):\n    \"\"\"Configuration for JWT generation and validation.\n    Placeholder for a more robust revocation list mechanism. This might not be directly configured\n    via YAML/env for a simple set. It's more of a runtime state that might be backed by Redis/DB.\n    For now, keeping it out of direct config loading, will be managed by auth module.\n    \"\"\"\n    secret_key: SecretStr = Field(\n        default_factory=lambda: SecretStr(\"your-default-super-secret-key-please-change\")\n    )\n    algorithm: str = Field(default=\"HS256\")",
        "detail": "src.aphelion.config",
        "documentation": {}
    },
    {
        "label": "LoggingConfigModel",
        "kind": 6,
        "importPath": "src.aphelion.config",
        "description": "src.aphelion.config",
        "peekOfCode": "class LoggingConfigModel(BaseModel):\n    \"\"\"Configuration for logging.\n    Example: format: str = Field(default=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n    \"\"\"\n    level: str = Field(default=\"INFO\")\n    file: Optional[Path] = Field(\n        default=None\n    )  # e.g., BASE_DIR / \"logs\" / \"aphelion.log\"\n    @field_validator(\"level\")\n    @classmethod",
        "detail": "src.aphelion.config",
        "documentation": {}
    },
    {
        "label": "AppConfigModel",
        "kind": 6,
        "importPath": "src.aphelion.config",
        "description": "src.aphelion.config",
        "peekOfCode": "class AppConfigModel(BaseSettings):\n    \"\"\"Main application settings model.\n    Loads settings from environment variables, .env files, and YAML files. Environment variables\n    take precedence.\n    \"\"\"\n    model_config = SettingsConfigDict(\n        env_prefix=\"APHELION_\",  # Environment variables should be prefixed (e.g., APHELION_JWT__SECRET_KEY)\n        env_nested_delimiter=\"__\",  # For nested models like JWTConfigModel\n        env_file=BASE_DIR / \".env\",  # Load from .env file if present\n        env_file_encoding=\"utf-8\",",
        "detail": "src.aphelion.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "src.aphelion.config",
        "description": "src.aphelion.config",
        "peekOfCode": "def get_config(config_file_path: Optional[Union[str, Path]] = None) -> AppConfigModel:\n    \"\"\"Retrieves the global configuration instance.\n    Loads it if it hasn't been loaded yet. Allows specifying a custom config file path for the\n    initial load.\n    \"\"\"\n    global _app_config\n    if _app_config is None:\n        effective_config_file = (\n            config_file_path or os.getenv(\"APHELION_CONFIG_FILE\") or DEFAULT_CONFIG_FILE\n        )",
        "detail": "src.aphelion.config",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "src.aphelion.config",
        "description": "src.aphelion.config",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent.parent.parent  # Project root\nDEFAULT_CONFIG_FILE = BASE_DIR / \"config\" / \"aphelion_config.yaml\"\n# --- Pydantic Models for Configuration Sections ---\nclass JWTConfigModel(BaseModel):\n    \"\"\"Configuration for JWT generation and validation.\n    Placeholder for a more robust revocation list mechanism. This might not be directly configured\n    via YAML/env for a simple set. It's more of a runtime state that might be backed by Redis/DB.\n    For now, keeping it out of direct config loading, will be managed by auth module.\n    \"\"\"\n    secret_key: SecretStr = Field(",
        "detail": "src.aphelion.config",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG_FILE",
        "kind": 5,
        "importPath": "src.aphelion.config",
        "description": "src.aphelion.config",
        "peekOfCode": "DEFAULT_CONFIG_FILE = BASE_DIR / \"config\" / \"aphelion_config.yaml\"\n# --- Pydantic Models for Configuration Sections ---\nclass JWTConfigModel(BaseModel):\n    \"\"\"Configuration for JWT generation and validation.\n    Placeholder for a more robust revocation list mechanism. This might not be directly configured\n    via YAML/env for a simple set. It's more of a runtime state that might be backed by Redis/DB.\n    For now, keeping it out of direct config loading, will be managed by auth module.\n    \"\"\"\n    secret_key: SecretStr = Field(\n        default_factory=lambda: SecretStr(\"your-default-super-secret-key-please-change\")",
        "detail": "src.aphelion.config",
        "documentation": {}
    },
    {
        "label": "get_greeting",
        "kind": 2,
        "importPath": "src.aphelion.main",
        "description": "src.aphelion.main",
        "peekOfCode": "def get_greeting() -> str:\n    \"\"\"\n    Returns a simple greeting string.\n    This is a placeholder function.\n    \"\"\"\n    return \"Hello from Aphelion!\"\nif __name__ == \"__main__\":\n    print(get_greeting())",
        "detail": "src.aphelion.main",
        "documentation": {}
    },
    {
        "label": "mocked_jwt_config_model",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def mocked_jwt_config_model() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel instance for tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_SECRET_KEY, # type: ignore [arg-type] # pydantic handles SecretStr\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5,\n        refresh_token_expire_days=1,\n    )\n@pytest.fixture(autouse=True)\ndef mock_aphelion_config_for_jwt_tests(mocked_jwt_config_model: JWTConfigModel):",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "mock_aphelion_config_for_jwt_tests",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def mock_aphelion_config_for_jwt_tests(mocked_jwt_config_model: JWTConfigModel):\n    \"\"\"\n    Patches get_config() within the aphelion.auth.jwt module to return a\n    test-specific AppConfigModel containing the mocked_jwt_config_model.\n    Also clears the JWT revocation store before and after each test.\n    \"\"\"\n    clear_revoked_tokens_store() # Clear before test runs\n    # Create a full AppConfigModel instance, embedding the mocked JWT config\n    test_app_config = AppConfigModel(jwt=mocked_jwt_config_model)\n    # The crucial part is to patch 'get_config' in the *module where it's used* (aphelion.auth.jwt)",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_create_access_token_default_claims",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_create_access_token_default_claims():\n    token = create_access_token(subject=TEST_SUBJECT)\n    payload = decode_token(token) # Use internal decode for direct payload inspection\n    assert payload[\"sub\"] == TEST_SUBJECT\n    assert payload[\"type\"] == \"access\"\n    assert \"exp\" in payload\n    assert \"iat\" in payload\n    assert \"iss\" in payload\n    assert payload[\"iss\"] == \"aphelion_security_framework\"\ndef test_create_access_token_with_additional_claims():",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_create_access_token_with_additional_claims",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_create_access_token_with_additional_claims():\n    token = create_access_token(subject=TEST_SUBJECT, additional_claims=TEST_ADDITIONAL_CLAIMS)\n    payload = decode_token(token)\n    assert payload[\"sub\"] == TEST_SUBJECT\n    assert payload[\"role\"] == TEST_ADDITIONAL_CLAIMS[\"role\"]\n    assert payload[\"scope\"] == TEST_ADDITIONAL_CLAIMS[\"scope\"]\n    assert payload[\"type\"] == \"access\"\ndef test_create_refresh_token():\n    token = create_refresh_token(subject=TEST_SUBJECT)\n    payload = decode_token(token)",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_create_refresh_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_create_refresh_token():\n    token = create_refresh_token(subject=TEST_SUBJECT)\n    payload = decode_token(token)\n    assert payload[\"sub\"] == TEST_SUBJECT\n    assert payload[\"type\"] == \"refresh\"\n    assert \"exp\" in payload\n    assert \"iat\" in payload\n    # Refresh tokens should not contain additional app-specific claims by default\n    assert \"role\" not in payload\ndef test_validate_valid_access_token():",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_valid_access_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_valid_access_token():\n    token = create_access_token(subject=TEST_SUBJECT, additional_claims=TEST_ADDITIONAL_CLAIMS)\n    payload = validate_token(token, expected_token_type=\"access\")\n    assert payload[\"sub\"] == TEST_SUBJECT\n    assert payload[\"role\"] == TEST_ADDITIONAL_CLAIMS[\"role\"]\ndef test_validate_valid_refresh_token():\n    token = create_refresh_token(subject=TEST_SUBJECT)\n    payload = validate_token(token, expected_token_type=\"refresh\")\n    assert payload[\"sub\"] == TEST_SUBJECT\ndef test_validate_token_no_type_check():",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_valid_refresh_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_valid_refresh_token():\n    token = create_refresh_token(subject=TEST_SUBJECT)\n    payload = validate_token(token, expected_token_type=\"refresh\")\n    assert payload[\"sub\"] == TEST_SUBJECT\ndef test_validate_token_no_type_check():\n    token = create_access_token(subject=TEST_SUBJECT)\n    payload = validate_token(token, expected_token_type=None) # Skip type check\n    assert payload[\"sub\"] == TEST_SUBJECT\n    assert payload[\"type\"] == \"access\"\ndef test_decode_expired_access_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_token_no_type_check",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_token_no_type_check():\n    token = create_access_token(subject=TEST_SUBJECT)\n    payload = validate_token(token, expected_token_type=None) # Skip type check\n    assert payload[\"sub\"] == TEST_SUBJECT\n    assert payload[\"type\"] == \"access\"\ndef test_decode_expired_access_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # Override the global mock for this specific test to set a past expiry\n    expired_jwt_config = mocked_jwt_config_model.model_copy(update={\"access_token_expire_minutes\": -1})\n    expired_app_config = AppConfigModel(jwt=expired_jwt_config)\n    mock_aphelion_config_for_jwt_tests.return_value = expired_app_config",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_decode_expired_access_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_decode_expired_access_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # Override the global mock for this specific test to set a past expiry\n    expired_jwt_config = mocked_jwt_config_model.model_copy(update={\"access_token_expire_minutes\": -1})\n    expired_app_config = AppConfigModel(jwt=expired_jwt_config)\n    mock_aphelion_config_for_jwt_tests.return_value = expired_app_config\n    token = create_access_token(subject=TEST_SUBJECT)\n    with pytest.raises(ExpiredTokenError):\n        decode_token(token)\ndef test_validate_expired_access_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # Override the global mock for this specific test for very short expiry",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_expired_access_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_expired_access_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # Override the global mock for this specific test for very short expiry\n    short_expiry_jwt_config = mocked_jwt_config_model.model_copy(\n        update={\"access_token_expire_minutes\": 1/6000} # Approx 0.01 seconds\n    )\n    short_expiry_app_config = AppConfigModel(jwt=short_expiry_jwt_config)\n    mock_aphelion_config_for_jwt_tests.return_value = short_expiry_app_config\n    token_short = create_access_token(subject=\"short_lived_user\")\n    time.sleep(0.1) # Wait for 0.1 seconds, should be enough for it to expire\n    with pytest.raises(ExpiredTokenError):",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_decode_invalid_signature_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_decode_invalid_signature_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # Create a token with the current (mocked) key\n    token = create_access_token(subject=TEST_SUBJECT)\n    # Now, change the config that get_config() will return for the decode step\n    # Pydantic should convert the string \"completely-different-secret\" to SecretStr\n    # Explicitly create SecretStr for the update to be certain.\n    from pydantic import SecretStr\n    wrong_key_jwt_config = mocked_jwt_config_model.model_copy(\n        update={\"secret_key\": SecretStr(\"completely-different-secret\")}\n    )",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_invalid_signature_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_invalid_signature_token(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # Create a token with the current (mocked) key\n    token = create_access_token(subject=TEST_SUBJECT)\n    # Change the config for the validation step\n    from pydantic import SecretStr\n    another_wrong_key_jwt_config = mocked_jwt_config_model.model_copy(\n        update={\"secret_key\": SecretStr(\"another-wrong-secret\")}\n    )\n    another_wrong_key_app_config = AppConfigModel(jwt=another_wrong_key_jwt_config)\n    mock_aphelion_config_for_jwt_tests.return_value = another_wrong_key_app_config",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_decode_malformed_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_decode_malformed_token():\n    malformed_token = \"this.is.not.a.jwt\"\n    with pytest.raises(InvalidTokenError) as excinfo:\n        decode_token(malformed_token)\n    # Check that our wrapper exception is raised. The specific PyJWT internal error can vary.\n    assert \"Token is invalid\" in str(excinfo.value)\ndef test_validate_malformed_token():\n    malformed_token = \"this.is.still.not.a.jwt\"\n    with pytest.raises(InvalidTokenError):\n        validate_token(malformed_token)",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_malformed_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_malformed_token():\n    malformed_token = \"this.is.still.not.a.jwt\"\n    with pytest.raises(InvalidTokenError):\n        validate_token(malformed_token)\ndef test_decode_missing_token():\n    with pytest.raises(MissingTokenError):\n        decode_token(\"\")\n    with pytest.raises(MissingTokenError):\n        decode_token(None) # type: ignore\ndef test_validate_missing_token():",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_decode_missing_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_decode_missing_token():\n    with pytest.raises(MissingTokenError):\n        decode_token(\"\")\n    with pytest.raises(MissingTokenError):\n        decode_token(None) # type: ignore\ndef test_validate_missing_token():\n    with pytest.raises(MissingTokenError):\n        validate_token(\"\")\n    with pytest.raises(MissingTokenError):\n        validate_token(None) # type: ignore",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_missing_token",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_missing_token():\n    with pytest.raises(MissingTokenError):\n        validate_token(\"\")\n    with pytest.raises(MissingTokenError):\n        validate_token(None) # type: ignore\ndef test_validate_wrong_token_type():\n    access_token = create_access_token(subject=TEST_SUBJECT)\n    with pytest.raises(InvalidTokenError) as excinfo:\n        validate_token(access_token, expected_token_type=\"refresh\")\n    assert \"Invalid token type. Expected 'refresh', got 'access'\" in str(excinfo.value)",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_validate_wrong_token_type",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_validate_wrong_token_type():\n    access_token = create_access_token(subject=TEST_SUBJECT)\n    with pytest.raises(InvalidTokenError) as excinfo:\n        validate_token(access_token, expected_token_type=\"refresh\")\n    assert \"Invalid token type. Expected 'refresh', got 'access'\" in str(excinfo.value)\n    refresh_token = create_refresh_token(subject=TEST_SUBJECT)\n    with pytest.raises(InvalidTokenError) as excinfo:\n        validate_token(refresh_token, expected_token_type=\"access\")\n    assert \"Invalid token type. Expected 'access', got 'refresh'\" in str(excinfo.value)\n# Removed test_create_token_missing_subject because create_access_token(subject=None)",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_token_revocation",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_token_revocation(): # Removed setup_jwt_config: JWTConfig argument\n    token_to_revoke1 = create_access_token(\"user_to_be_revoked_1\")\n    token_to_revoke2 = create_refresh_token(\"user_to_be_revoked_2\")\n    token_not_revoked = create_access_token(\"user_not_revoked\")\n    # Ensure tokens are initially valid and not revoked\n    assert is_token_revoked(token_to_revoke1) is False\n    validate_token(token_to_revoke1)\n    assert is_token_revoked(token_to_revoke2) is False\n    validate_token(token_to_revoke2, expected_token_type=\"refresh\")\n    assert is_token_revoked(token_not_revoked) is False",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_jwt_behavior_with_changed_config_algorithm",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_jwt_behavior_with_changed_config_algorithm(\n    mock_aphelion_config_for_jwt_tests: MagicMock,\n    mocked_jwt_config_model: JWTConfigModel\n):\n    # 1. Create token with default HS256 algorithm (from main fixture)\n    token_hs256 = create_access_token(TEST_SUBJECT)\n    # Validate it works with HS256\n    payload_hs256 = validate_token(token_hs256)\n    assert payload_hs256[\"sub\"] == TEST_SUBJECT\n    # 2. Change the live JWT config to use HS512 for subsequent operations",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_token_nbf_claim",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_token_nbf_claim(mock_aphelion_config_for_jwt_tests: MagicMock, mocked_jwt_config_model: JWTConfigModel):\n    # \"nbf\" (Not Before) claim\n    # For this, we need to inject 'nbf' into the token creation.\n    # Let's assume _create_token could be extended or we craft it manually.\n    nbf_time = int(time.time()) + 300  # Token not valid for 300 seconds\n    iat_time = int(time.time())\n    # Use the mocked_jwt_config_model passed to the test\n    exp_time = iat_time + mocked_jwt_config_model.access_token_expire_minutes * 60\n    custom_payload = {\n        \"sub\": TEST_SUBJECT,",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "test_default_test_secret_is_not_app_placeholder",
        "kind": 2,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "def test_default_test_secret_is_not_app_placeholder(mock_aphelion_config_for_jwt_tests: MagicMock):\n    # The mock_aphelion_config_for_jwt_tests fixture sets up get_config() to return\n    # an AppConfigModel containing a JWTConfigModel with DEFAULT_TEST_SECRET_KEY.\n    # We access this through the mock of get_config if we want to inspect its return_value,\n    # or by calling get_config() itself (which will return the mocked value).\n    from aphelion.auth.jwt import get_config # Import it here to ensure it's the one from jwt module\n    current_jwt_config = get_config().jwt # This will use the mocked get_config\n    assert current_jwt_config.secret_key.get_secret_value() == DEFAULT_TEST_SECRET_KEY\n    assert current_jwt_config.secret_key.get_secret_value() != \"your-default-super-secret-key-please-change\"\n    # Also check the algorithm to be sure we have the right test config",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "TEST_SUBJECT",
        "kind": 5,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "TEST_SUBJECT = \"test_user_123\"\nTEST_ADDITIONAL_CLAIMS = {\"role\": \"tester\", \"scope\": \"read:data\"}\nDEFAULT_TEST_SECRET_KEY = \"test-secret-key-for-pytest\"\n@pytest.fixture\ndef mocked_jwt_config_model() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel instance for tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_SECRET_KEY, # type: ignore [arg-type] # pydantic handles SecretStr\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5,",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "TEST_ADDITIONAL_CLAIMS",
        "kind": 5,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "TEST_ADDITIONAL_CLAIMS = {\"role\": \"tester\", \"scope\": \"read:data\"}\nDEFAULT_TEST_SECRET_KEY = \"test-secret-key-for-pytest\"\n@pytest.fixture\ndef mocked_jwt_config_model() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel instance for tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_SECRET_KEY, # type: ignore [arg-type] # pydantic handles SecretStr\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5,\n        refresh_token_expire_days=1,",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TEST_SECRET_KEY",
        "kind": 5,
        "importPath": "tests.auth.test_jwt",
        "description": "tests.auth.test_jwt",
        "peekOfCode": "DEFAULT_TEST_SECRET_KEY = \"test-secret-key-for-pytest\"\n@pytest.fixture\ndef mocked_jwt_config_model() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel instance for tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_SECRET_KEY, # type: ignore [arg-type] # pydantic handles SecretStr\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5,\n        refresh_token_expire_days=1,\n    )",
        "detail": "tests.auth.test_jwt",
        "documentation": {}
    },
    {
        "label": "reset_target_module_enforcer",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def reset_target_module_enforcer():\n    \"\"\"\n    Ensures the _enforcer in the aphelion.authz.casbin_enforcer module\n    is reset to None before each test and restored afterwards.\n    \"\"\"\n    import aphelion.authz.casbin_enforcer as ce_module\n    original_module_enforcer = ce_module._enforcer\n    ce_module._enforcer = None\n    yield\n    ce_module._enforcer = original_module_enforcer",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "default_model_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def default_model_file() -> Path:\n    # Ensure this points to the actual default model file relative to project root\n    project_root = Path(__file__).resolve().parent.parent.parent\n    model_path = project_root / \"config\" / \"rbac_model.conf\"\n    if not model_path.exists():\n        pytest.fail(f\"Default model file not found for tests: {model_path}\")\n    return model_path\n@pytest.fixture\ndef default_policy_file() -> Path:\n    project_root = Path(__file__).resolve().parent.parent.parent",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "default_policy_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def default_policy_file() -> Path:\n    project_root = Path(__file__).resolve().parent.parent.parent\n    policy_path = project_root / \"config\" / \"rbac_policy.csv\"\n    if not policy_path.exists():\n        pytest.fail(f\"Default policy file not found for tests: {policy_path}\")\n    return policy_path\n@pytest.fixture\ndef temp_model_file(tmp_path: Path) -> Path:\n    model_content = \"\"\"\n[request_definition]",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "temp_model_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def temp_model_file(tmp_path: Path) -> Path:\n    model_content = \"\"\"\n[request_definition]\nr = sub, obj, act\n[policy_definition]\np = sub, obj, act\n[role_definition]\ng = _, _\n[policy_effect]\ne = some(where (p.eft == allow))",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "temp_policy_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def temp_policy_file(tmp_path: Path) -> Path:\n    policy_content = \"\"\"\np, test_admin, resource1, read\np, test_admin, resource1, write\np, test_user, resource1, read\ng, alice_test, test_admin\n    \"\"\"\n    file_path = tmp_path / \"test_policy.csv\"\n    file_path.write_text(policy_content)\n    return file_path",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_init_enforcer_default_paths",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_init_enforcer_default_paths(default_model_file, default_policy_file):\n    \"\"\"Test enforcer initialization with default model and policy files.\"\"\"\n    # Patch the constants in casbin_enforcer to ensure they point to our test-verified paths\n    # This is important if the test execution environment base path differs from module's expectation.\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            enforcer = init_enforcer()\n            assert isinstance(enforcer, casbin.Enforcer)\n            assert enforcer is get_enforcer() # Should return the same instance\ndef test_init_enforcer_custom_paths(temp_model_file: Path, temp_policy_file: Path):",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_init_enforcer_custom_paths",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_init_enforcer_custom_paths(temp_model_file: Path, temp_policy_file: Path):\n    \"\"\"Test enforcer initialization with custom model and policy files.\"\"\"\n    enforcer = init_enforcer(model_path=temp_model_file, policy_adapter=temp_policy_file)\n    assert isinstance(enforcer, casbin.Enforcer)\n    # Check if it loaded the custom policy\n    assert enforcer.enforce(\"test_admin\", \"resource1\", \"read\") is True\n    assert enforcer.enforce(\"alice_test\", \"resource1\", \"write\") is True # via role\n    assert enforcer.enforce(\"test_user\", \"resource1\", \"write\") is False\ndef test_init_enforcer_missing_model_file(tmp_path: Path, default_policy_file):\n    \"\"\"Test PolicyError when model file is missing.\"\"\"",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_init_enforcer_missing_model_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_init_enforcer_missing_model_file(tmp_path: Path, default_policy_file):\n    \"\"\"Test PolicyError when model file is missing.\"\"\"\n    missing_model_path = tmp_path / \"non_existent_model.conf\"\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n      with pytest.raises(PolicyError, match=\"Casbin model file not found\"):\n          init_enforcer(model_path=missing_model_path)\ndef test_init_enforcer_missing_policy_file(default_model_file, tmp_path: Path):\n    \"\"\"Test PolicyError when policy file is missing.\"\"\"\n    missing_policy_path = tmp_path / \"non_existent_policy.csv\"\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_init_enforcer_missing_policy_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_init_enforcer_missing_policy_file(default_model_file, tmp_path: Path):\n    \"\"\"Test PolicyError when policy file is missing.\"\"\"\n    missing_policy_path = tmp_path / \"non_existent_policy.csv\"\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n      # Casbin's FileAdapter itself raises \"invalid file path\" if it's missing on load attempt.\n      # Our wrapper catches this and re-raises.\n      with pytest.raises(PolicyError, match=\"Failed to initialize Casbin enforcer: invalid file path\"):\n          init_enforcer(policy_adapter=missing_policy_path)\ndef test_get_enforcer_initializes_if_none(default_model_file, default_policy_file):\n    \"\"\"Test get_enforcer() initializes with defaults if not already done.\"\"\"",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_get_enforcer_initializes_if_none",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_get_enforcer_initializes_if_none(default_model_file, default_policy_file):\n    \"\"\"Test get_enforcer() initializes with defaults if not already done.\"\"\"\n    import aphelion.authz.casbin_enforcer as ce_module # Import for direct access\n    # Pre-condition: The fixture should have set the target module's _enforcer to None\n    assert ce_module._enforcer is None\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            enforcer = get_enforcer()\n            assert isinstance(enforcer, casbin.Enforcer)\n            # Post-condition: The target module's _enforcer should now be the initialized enforcer",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_init_enforcer_returns_same_instance_if_paths_match",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_init_enforcer_returns_same_instance_if_paths_match(default_model_file, default_policy_file):\n    # This test relies on the global _enforcer state, so direct checks are also good.\n    import aphelion.authz.casbin_enforcer as ce_module\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            e1 = init_enforcer()\n            assert ce_module._enforcer is e1 # Global is set to e1\n            e2 = init_enforcer() # Calling again with same implicit paths\n            assert e1 is e2      # Should return the same instance from global\n            assert ce_module._enforcer is e1 # Global should remain e1",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_init_enforcer_reinitializes_if_model_path_differs",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_init_enforcer_reinitializes_if_model_path_differs(default_model_file, default_policy_file, temp_model_file):\n    import aphelion.authz.casbin_enforcer as ce_module\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            e1 = init_enforcer()\n            assert ce_module._enforcer is e1 # Global is e1\n            # Use the same temp_policy_file to isolate model change, or default_policy_file\n            e2 = init_enforcer(model_path=temp_model_file, policy_adapter=default_policy_file)\n            assert e1 is not e2\n            assert ce_module._enforcer is e2 # Global should now be e2",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_enforce_default_policies",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_enforce_default_policies(subject, obj, action, expected_auth, default_model_file, default_policy_file):\n    # Ensure enforcer is initialized with default files for these tests\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            init_enforcer()\n            assert enforce(subject, obj, action) is expected_auth\ndef test_enforce_uninitialized_raises_policy_error_via_get_enforcer(tmp_path):\n    \"\"\"Test that enforce calls get_enforcer which might raise PolicyError if init fails.\"\"\"\n    global global_enforcer_instance\n    global_enforcer_instance = None # Ensure it's not initialized",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_enforce_uninitialized_raises_policy_error_via_get_enforcer",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_enforce_uninitialized_raises_policy_error_via_get_enforcer(tmp_path):\n    \"\"\"Test that enforce calls get_enforcer which might raise PolicyError if init fails.\"\"\"\n    global global_enforcer_instance\n    global_enforcer_instance = None # Ensure it's not initialized\n    # Make default model path invalid to cause init failure\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', tmp_path / \"bad_model.conf\"):\n        with pytest.raises(PolicyError):\n            enforce(\"sub\", \"obj\", \"act\")\n# Future: If `enforce` is changed to raise NotAuthorizedError:\n# def test_enforce_raises_not_authorized_error(default_model_file, default_policy_file):",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_add_and_remove_policy_rule",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_add_and_remove_policy_rule(temp_model_file, temp_policy_file):\n    \"\"\"Test adding and removing a 'p' policy rule.\"\"\"\n    enforcer = init_enforcer(model_path=temp_model_file, policy_adapter=temp_policy_file)\n    from aphelion.authz.casbin_enforcer import add_policy_rule, remove_policy_rule, enforce as aphelion_enforce\n    sub, obj, act = \"new_user\", \"new_resource\", \"new_action\"\n    assert aphelion_enforce(sub, obj, act) is False # Should not exist initially\n    # Add policy\n    assert add_policy_rule(sub, obj, act) is True\n    assert aphelion_enforce(sub, obj, act) is True\n    # Try adding again (should return False as it already exists)",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_add_and_remove_grouping_policy_rule",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_add_and_remove_grouping_policy_rule(temp_model_file, temp_policy_file):\n    \"\"\"Test adding and removing a 'g' (grouping/role) policy rule.\"\"\"\n    enforcer = init_enforcer(model_path=temp_model_file, policy_adapter=temp_policy_file)\n    from aphelion.authz.casbin_enforcer import (\n        add_grouping_policy_rule, remove_grouping_policy_rule,\n        add_policy_rule, enforce as aphelion_enforce\n    )\n    user, role = \"dave_user\", \"temp_editor_role\"\n    obj, act = \"documentX\", \"edit\"\n    # Add a policy for the role first",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_get_all_policy_rules",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_get_all_policy_rules(default_model_file, default_policy_file):\n    \"\"\"Test retrieving all 'p' policies.\"\"\"\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            init_enforcer()\n            from aphelion.authz.casbin_enforcer import get_all_policy_rules\n            rules = get_all_policy_rules()\n            assert isinstance(rules, list)\n            # Based on default_policy.csv, check a few expected rules\n            # Note: order might not be guaranteed, so check for presence",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_get_all_grouping_policy_rules",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_get_all_grouping_policy_rules(default_model_file, default_policy_file):\n    \"\"\"Test retrieving all 'g' policies.\"\"\"\n    with patch('aphelion.authz.casbin_enforcer.DEFAULT_MODEL_PATH', default_model_file):\n        with patch('aphelion.authz.casbin_enforcer.DEFAULT_POLICY_PATH', default_policy_file):\n            init_enforcer()\n            from aphelion.authz.casbin_enforcer import get_all_grouping_policy_rules\n            grouping_rules = get_all_grouping_policy_rules()\n            assert isinstance(grouping_rules, list)\n            expected_alice_admin = [\"alice\", \"admin\"]\n            assert any(rule == expected_alice_admin for rule in grouping_rules)",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_save_policy_to_file",
        "kind": 2,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "def test_save_policy_to_file(temp_model_file, tmp_path: Path):\n    \"\"\"Test saving policy to a file using FileAdapter.\"\"\"\n    # Use a fresh policy file for this test to check its content after save\n    temp_policy_for_save = tmp_path / \"policy_for_save.csv\"\n    temp_policy_for_save.touch() # Create the file so FileAdapter can load it (empty)\n    enforcer = init_enforcer(model_path=temp_model_file, policy_adapter=temp_policy_for_save)\n    from aphelion.authz.casbin_enforcer import add_policy_rule, save_policy_to_file\n    # Add a rule, it's in memory\n    add_policy_rule(\"user_save_test\", \"resource_save\", \"action_save\")\n    assert enforcer.enforce(\"user_save_test\", \"resource_save\", \"action_save\")",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "r = sub, obj, act\n[policy_definition]\np = sub, obj, act\n[role_definition]\ng = _, _\n[policy_effect]\ne = some(where (p.eft == allow))\n[matchers]\nm = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n    \"\"\"",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "p = sub, obj, act\n[role_definition]\ng = _, _\n[policy_effect]\ne = some(where (p.eft == allow))\n[matchers]\nm = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n    \"\"\"\n    file_path = tmp_path / \"test_model.conf\"\n    file_path.write_text(model_content)",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "g = _, _\n[policy_effect]\ne = some(where (p.eft == allow))\n[matchers]\nm = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n    \"\"\"\n    file_path = tmp_path / \"test_model.conf\"\n    file_path.write_text(model_content)\n    return file_path\n@pytest.fixture",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "e",
        "kind": 5,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "e = some(where (p.eft == allow))\n[matchers]\nm = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n    \"\"\"\n    file_path = tmp_path / \"test_model.conf\"\n    file_path.write_text(model_content)\n    return file_path\n@pytest.fixture\ndef temp_policy_file(tmp_path: Path) -> Path:\n    policy_content = \"\"\"",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "tests.authz.test_casbin_enforcer",
        "description": "tests.authz.test_casbin_enforcer",
        "peekOfCode": "m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n    \"\"\"\n    file_path = tmp_path / \"test_model.conf\"\n    file_path.write_text(model_content)\n    return file_path\n@pytest.fixture\ndef temp_policy_file(tmp_path: Path) -> Path:\n    policy_content = \"\"\"\np, test_admin, resource1, read\np, test_admin, resource1, write",
        "detail": "tests.authz.test_casbin_enforcer",
        "documentation": {}
    },
    {
        "label": "test_jwt_config_for_fastapi",
        "kind": 2,
        "importPath": "tests.frameworks.fastapi.test_middleware",
        "description": "tests.frameworks.fastapi.test_middleware",
        "peekOfCode": "def test_jwt_config_for_fastapi() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel for FastAPI middleware tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_FASTAPI_SECRET_KEY, # type: ignore\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5, # Short expiry for testing is good\n    )\n@pytest.fixture(scope=\"function\") # Use function scope for test isolation\ndef mock_aphelion_config_for_fastapi_tests(test_jwt_config_for_fastapi: JWTConfigModel):\n    \"\"\"",
        "detail": "tests.frameworks.fastapi.test_middleware",
        "documentation": {}
    },
    {
        "label": "mock_aphelion_config_for_fastapi_tests",
        "kind": 2,
        "importPath": "tests.frameworks.fastapi.test_middleware",
        "description": "tests.frameworks.fastapi.test_middleware",
        "peekOfCode": "def mock_aphelion_config_for_fastapi_tests(test_jwt_config_for_fastapi: JWTConfigModel):\n    \"\"\"\n    Patches get_config() for the duration of a test function to return a\n    test-specific AppConfig, primarily for JWT settings.\n    This fixture ensures that JWT creation and validation within the middleware\n    and token generation utilities use a consistent, test-specific secret key and settings.\n    \"\"\"\n    test_app_config = AppConfigModel(jwt=test_jwt_config_for_fastapi)\n    # Patch get_config in the 'aphelion.auth.jwt' module, as this is where\n    # create_access_token and validate_aphelion_token (used by the middleware)",
        "detail": "tests.frameworks.fastapi.test_middleware",
        "documentation": {}
    },
    {
        "label": "create_test_app",
        "kind": 2,
        "importPath": "tests.frameworks.fastapi.test_middleware",
        "description": "tests.frameworks.fastapi.test_middleware",
        "peekOfCode": "def create_test_app(public_paths: Optional[set[str]] = None) -> FastAPI:\n    \"\"\"Helper to create a FastAPI app instance with the middleware.\"\"\"\n    app = FastAPI(title=\"TestAppWithAphelionMiddleware\")\n    app.add_middleware(AphelionFastAPIMiddleware, public_paths=public_paths or {\"/public\"})\n    @app.get(\"/public\")\n    async def public_route():\n        return {\"message\": \"Public access granted\"}\n    @app.get(\"/protected_state\")\n    async def protected_route_state(request: Request):\n        subject = getattr(request.state, \"subject\", None)",
        "detail": "tests.frameworks.fastapi.test_middleware",
        "documentation": {}
    },
    {
        "label": "test_path_matching_in_middleware",
        "kind": 2,
        "importPath": "tests.frameworks.fastapi.test_middleware",
        "description": "tests.frameworks.fastapi.test_middleware",
        "peekOfCode": "def test_path_matching_in_middleware():\n    # Test the path matching logic of the middleware (not via HTTP client)\n    # This is a unit test for a part of the middleware logic.\n    # Dummy request and call_next for synchronous testing of this part\n    class DummyRequest:\n        def __init__(self, path):\n            class URL:\n                def __init__(self, path_str):\n                    self.path = path_str\n            self.url = URL(path)",
        "detail": "tests.frameworks.fastapi.test_middleware",
        "documentation": {}
    },
    {
        "label": "TEST_SUBJECT_ID",
        "kind": 5,
        "importPath": "tests.frameworks.fastapi.test_middleware",
        "description": "tests.frameworks.fastapi.test_middleware",
        "peekOfCode": "TEST_SUBJECT_ID = \"test_fastapi_user\"\nDEFAULT_TEST_FASTAPI_SECRET_KEY = \"fastapi-middleware-test-secret\"\n@pytest.fixture\ndef test_jwt_config_for_fastapi() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel for FastAPI middleware tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_FASTAPI_SECRET_KEY, # type: ignore\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5, # Short expiry for testing is good\n    )",
        "detail": "tests.frameworks.fastapi.test_middleware",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TEST_FASTAPI_SECRET_KEY",
        "kind": 5,
        "importPath": "tests.frameworks.fastapi.test_middleware",
        "description": "tests.frameworks.fastapi.test_middleware",
        "peekOfCode": "DEFAULT_TEST_FASTAPI_SECRET_KEY = \"fastapi-middleware-test-secret\"\n@pytest.fixture\ndef test_jwt_config_for_fastapi() -> JWTConfigModel:\n    \"\"\"Provides a consistent JWTConfigModel for FastAPI middleware tests.\"\"\"\n    return JWTConfigModel(\n        secret_key=DEFAULT_TEST_FASTAPI_SECRET_KEY, # type: ignore\n        algorithm=\"HS256\",\n        access_token_expire_minutes=5, # Short expiry for testing is good\n    )\n@pytest.fixture(scope=\"function\") # Use function scope for test isolation",
        "detail": "tests.frameworks.fastapi.test_middleware",
        "documentation": {}
    },
    {
        "label": "GIVEN_FUNCTION_TO_FUZZ_DOES_NOT_YET_EXIST_SO_THIS_IS_A_PLACEHOLDER",
        "kind": 2,
        "importPath": "tests.security.test_fuzzing_examples",
        "description": "tests.security.test_fuzzing_examples",
        "peekOfCode": "def GIVEN_FUNCTION_TO_FUZZ_DOES_NOT_YET_EXIST_SO_THIS_IS_A_PLACEHOLDER(input_string: str) -> str:\n    \"\"\"\n    A placeholder function. In a real scenario, this would be a function\n    from the main codebase that processes input and should be resilient.\n    Example: It might try to parse a complex string or sanitize it.\n    \"\"\"\n    if input_string is None:\n        raise TypeError(\"Input cannot be None\")\n    # Simple example: just returns the string, or a modified version.\n    # A real function might have complex logic prone to errors with weird inputs.",
        "detail": "tests.security.test_fuzzing_examples",
        "documentation": {}
    },
    {
        "label": "test_placeholder_fuzz_example",
        "kind": 2,
        "importPath": "tests.security.test_fuzzing_examples",
        "description": "tests.security.test_fuzzing_examples",
        "peekOfCode": "def test_placeholder_fuzz_example(sample_text: str):\n    \"\"\"\n    Example of a Hypothesis test. This would target a real function\n    in the Aphelion framework that needs to be robust against varied string inputs.\n    \"\"\"\n    try:\n        result = GIVEN_FUNCTION_TO_FUZZ_DOES_NOT_YET_EXIST_SO_THIS_IS_A_PLACEHOLDER(sample_text)\n        assert isinstance(result, str)\n        if sample_text is not None: # Guarding due to st.text() possibly generating complex objects if not careful\n            assert sample_text in result",
        "detail": "tests.security.test_fuzzing_examples",
        "documentation": {}
    },
    {
        "label": "simple_string_processor",
        "kind": 2,
        "importPath": "tests.security.test_fuzzing_examples",
        "description": "tests.security.test_fuzzing_examples",
        "peekOfCode": "def simple_string_processor(s: str) -> str:\n    if not isinstance(s, str):\n        # This case should ideally not be hit if st.text() is used,\n        # as it generates strings. But good for robustness.\n        raise TypeError(\"Input must be a string\")\n    return s.lower() # Example processing\n@settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)\n@given(st.text())\ndef test_simple_string_processor_does_not_crash(text_input: str):\n    \"\"\"",
        "detail": "tests.security.test_fuzzing_examples",
        "documentation": {}
    },
    {
        "label": "test_simple_string_processor_does_not_crash",
        "kind": 2,
        "importPath": "tests.security.test_fuzzing_examples",
        "description": "tests.security.test_fuzzing_examples",
        "peekOfCode": "def test_simple_string_processor_does_not_crash(text_input: str):\n    \"\"\"\n    Tests that simple_string_processor runs without unhandled exceptions\n    for any text input provided by Hypothesis.\n    \"\"\"\n    processed_text = simple_string_processor(text_input)\n    assert isinstance(processed_text, str)\n    assert processed_text == text_input.lower()\n@settings(suppress_health_check=[HealthCheck.too_slow], deadline=None)\n@given(st.integers())",
        "detail": "tests.security.test_fuzzing_examples",
        "documentation": {}
    },
    {
        "label": "test_another_placeholder_fuzz_integers",
        "kind": 2,
        "importPath": "tests.security.test_fuzzing_examples",
        "description": "tests.security.test_fuzzing_examples",
        "peekOfCode": "def test_another_placeholder_fuzz_integers(num_input: int):\n    \"\"\"Another example with integers.\"\"\"\n    assert isinstance(num_input, int)\n    # In a real test, call a function with num_input and assert properties.\n    pass",
        "detail": "tests.security.test_fuzzing_examples",
        "documentation": {}
    },
    {
        "label": "setup_module",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def setup_module(module):\n    \"\"\"Save original environment variables that might be modified by tests.\"\"\"\n    vars_to_save = [\n        \"APHELION_APP_NAME\",\n        \"APHELION_DEBUG_MODE\",\n        \"APHELION_JWT__SECRET_KEY\",\n        \"APHELION_JWT__ALGORITHM\",\n        \"APHELION_JWT__ACCESS_TOKEN_EXPIRE_MINUTES\",\n        \"APHELION_LOGGING__LEVEL\",\n        \"APHELION_CONFIG_FILE\" # If used to redirect config loading globally",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "teardown_module",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def teardown_module(module):\n    \"\"\"Restore original environment variables.\"\"\"\n    for var_name, value in ORIGINAL_ENV_VARS.items():\n        os.environ[var_name] = value\n    # Clean up any env vars set by tests that weren't originally there\n    test_set_vars = [\n        \"APHELION_APP_NAME\", \"APHELION_DEBUG_MODE\", \"APHELION_JWT__SECRET_KEY\",\n        \"APHELION_JWT__ALGORITHM\", \"APHELION_JWT__ACCESS_TOKEN_EXPIRE_MINUTES\",\n        \"APHELION_LOGGING__LEVEL\", \"APHELION_CONFIG_FILE\"\n    ]",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "reset_global_config_and_env",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def reset_global_config_and_env(monkeypatch):\n    \"\"\"\n    Resets the global _app_config in aphelion.config to None before each test,\n    and cleans up specific environment variables set by tests.\n    \"\"\"\n    # Reset the internal _app_config variable in the config module\n    # This forces get_config() to reload in each test if called.\n    with patch('aphelion.config._app_config', None):\n        # Clean specific env vars using monkeypatch for safety\n        env_vars_to_clear = [",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "dummy_config_yaml_file",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def dummy_config_yaml_file(tmp_path: Path) -> Path:\n    \"\"\"Creates a temporary YAML config file for testing.\"\"\"\n    config_content = {\n        \"app_name\": \"Test App YAML\",\n        \"debug_mode\": True,\n        \"jwt\": {\n            \"secret_key\": \"yaml_secret\",\n            \"algorithm\": \"HS512\",\n            \"access_token_expire_minutes\": 60,\n        },",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_load_defaults_no_file_no_env",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_load_defaults_no_file_no_env():\n    \"\"\"Test that default values are loaded if no config file or env vars are set.\"\"\"\n    # Ensure no config file is pointed to by env var for this test\n    if \"APHELION_CONFIG_FILE\" in os.environ:\n        del os.environ[\"APHELION_CONFIG_FILE\"]\n    # Patch DEFAULT_CONFIG_FILE to point to a non-existent file for this test\n    with patch('aphelion.config.DEFAULT_CONFIG_FILE', BASE_DIR_FOR_TESTS / \"non_existent_config.yaml\"):\n        config = get_config()\n    assert config.app_name == \"Aphelion Security Framework\" # Default\n    assert config.debug_mode is False # Default",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_load_from_yaml_file",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_load_from_yaml_file(dummy_config_yaml_file: Path):\n    \"\"\"Test loading configuration purely from a YAML file.\"\"\"\n    config = get_config(config_file_path=dummy_config_yaml_file)\n    assert config.app_name == \"Test App YAML\"\n    assert config.debug_mode is True\n    assert config.jwt.secret_key.get_secret_value() == \"yaml_secret\"\n    assert config.jwt.algorithm == \"HS512\"\n    assert config.jwt.access_token_expire_minutes == 60\n    assert config.logging.level == \"DEBUG\"\n    assert str(config.logging.file) == \"/tmp/test_app.log\" # Path objects comparison",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_load_from_env_vars_override_yaml",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_load_from_env_vars_override_yaml(dummy_config_yaml_file: Path, monkeypatch):\n    \"\"\"Test that environment variables override YAML file settings.\"\"\"\n    monkeypatch.setenv(\"APHELION_APP_NAME\", \"Test App ENV\")\n    monkeypatch.setenv(\"APHELION_DEBUG_MODE\", \"false\") # Note: pydantic-settings handles bool conversion\n    monkeypatch.setenv(\"APHELION_JWT__SECRET_KEY\", \"env_secret\")\n    monkeypatch.setenv(\"APHELION_JWT__ALGORITHM\", \"RS256\")\n    monkeypatch.setenv(\"APHELION_LOGGING__LEVEL\", \"ERROR\")\n    config = get_config(config_file_path=dummy_config_yaml_file)\n    assert config.app_name == \"Test App ENV\"\n    assert config.debug_mode is False # Pydantic converts \"false\"",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_load_from_env_vars_only",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_load_from_env_vars_only(monkeypatch):\n    \"\"\"Test loading configuration purely from environment variables (no YAML file).\"\"\"\n    monkeypatch.setenv(\"APHELION_APP_NAME\", \"ENV App Only\")\n    monkeypatch.setenv(\"APHELION_DEBUG_MODE\", \"true\")\n    monkeypatch.setenv(\"APHELION_JWT__SECRET_KEY\", \"env_only_secret\")\n    monkeypatch.setenv(\"APHELION_JWT__ALGORITHM\", \"ES256\")\n    monkeypatch.setenv(\"APHELION_JWT__ACCESS_TOKEN_EXPIRE_MINUTES\", \"15\")\n    monkeypatch.setenv(\"APHELION_LOGGING__LEVEL\", \"CRITICAL\")\n    # Patch DEFAULT_CONFIG_FILE to a non-existent one to ensure no YAML is loaded\n    with patch('aphelion.config.DEFAULT_CONFIG_FILE', BASE_DIR_FOR_TESTS / \"no_such_config.yaml\"):",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_jwt_config_invalid_algorithm_in_yaml",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_jwt_config_invalid_algorithm_in_yaml(tmp_path: Path):\n    \"\"\"Test validation error for unsupported JWT algorithm in YAML.\"\"\"\n    config_content = {\"jwt\": {\"algorithm\": \"INVALID_ALGO\"}}\n    yaml_file = tmp_path / \"invalid_algo.yaml\"\n    with open(yaml_file, 'w') as f:\n        yaml.dump(config_content, f)\n    with pytest.raises(ValidationError) as excinfo:\n        get_config(config_file_path=yaml_file)\n    assert \"Unsupported JWT algorithm: INVALID_ALGO\" in str(excinfo.value)\ndef test_logging_config_invalid_level_in_env(monkeypatch):",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_logging_config_invalid_level_in_env",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_logging_config_invalid_level_in_env(monkeypatch):\n    \"\"\"Test validation error for invalid logging level from environment.\"\"\"\n    monkeypatch.setenv(\"APHELION_LOGGING__LEVEL\", \"SUPER_VERBOSE\")\n    with patch('aphelion.config.DEFAULT_CONFIG_FILE', BASE_DIR_FOR_TESTS / \"no_such_config.yaml\"):\n        with pytest.raises(ValidationError) as excinfo:\n            get_config()\n    assert \"Invalid log level: SUPER_VERBOSE\" in str(excinfo.value)\ndef test_secret_str_hides_secret_in_repr():\n    \"\"\"Test that SecretStr correctly hides the secret key in representations.\"\"\"\n    config = AppConfigModel(jwt=JWTConfigModel(secret_key=\"my_very_secret_key\")) # type: ignore",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_secret_str_hides_secret_in_repr",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_secret_str_hides_secret_in_repr():\n    \"\"\"Test that SecretStr correctly hides the secret key in representations.\"\"\"\n    config = AppConfigModel(jwt=JWTConfigModel(secret_key=\"my_very_secret_key\")) # type: ignore\n    assert \"my_very_secret_key\" not in repr(config.jwt.secret_key)\n    assert \"**********\" in repr(config.jwt.secret_key)\n    assert config.jwt.secret_key.get_secret_value() == \"my_very_secret_key\"\ndef test_config_file_env_variable_precedence(tmp_path: Path, monkeypatch):\n    \"\"\"Test APHELION_CONFIG_FILE environment variable overrides default path.\"\"\"\n    default_yaml_content = {\"app_name\": \"Default YAML Name\"}\n    default_config_dir = tmp_path / \"default_config_dir\"",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_config_file_env_variable_precedence",
        "kind": 2,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "def test_config_file_env_variable_precedence(tmp_path: Path, monkeypatch):\n    \"\"\"Test APHELION_CONFIG_FILE environment variable overrides default path.\"\"\"\n    default_yaml_content = {\"app_name\": \"Default YAML Name\"}\n    default_config_dir = tmp_path / \"default_config_dir\"\n    default_config_dir.mkdir()\n    default_yaml_file = default_config_dir / \"aphelion_config.yaml\" # Simulates DEFAULT_CONFIG_FILE\n    with open(default_yaml_file, 'w') as f:\n        yaml.dump(default_yaml_content, f)\n    custom_yaml_content = {\"app_name\": \"Custom YAML Name via ENV Var\"}\n    custom_yaml_file = tmp_path / \"custom_path.yaml\"",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "BASE_DIR_FOR_TESTS",
        "kind": 5,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "BASE_DIR_FOR_TESTS = Path(__file__).resolve().parent.parent # Project root for test context\n# Store original env vars to restore them after tests\nORIGINAL_ENV_VARS = {}\ndef setup_module(module):\n    \"\"\"Save original environment variables that might be modified by tests.\"\"\"\n    vars_to_save = [\n        \"APHELION_APP_NAME\",\n        \"APHELION_DEBUG_MODE\",\n        \"APHELION_JWT__SECRET_KEY\",\n        \"APHELION_JWT__ALGORITHM\",",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "ORIGINAL_ENV_VARS",
        "kind": 5,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "ORIGINAL_ENV_VARS = {}\ndef setup_module(module):\n    \"\"\"Save original environment variables that might be modified by tests.\"\"\"\n    vars_to_save = [\n        \"APHELION_APP_NAME\",\n        \"APHELION_DEBUG_MODE\",\n        \"APHELION_JWT__SECRET_KEY\",\n        \"APHELION_JWT__ALGORITHM\",\n        \"APHELION_JWT__ACCESS_TOKEN_EXPIRE_MINUTES\",\n        \"APHELION_LOGGING__LEVEL\",",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "test_get_greeting",
        "kind": 2,
        "importPath": "tests.test_main",
        "description": "tests.test_main",
        "peekOfCode": "def test_get_greeting():\n    \"\"\"\n    Tests the get_greeting function from main.py.\n    \"\"\"\n    assert get_greeting() == \"Hello from Aphelion!\"\ndef test_placeholder_true():\n    \"\"\"\n    A placeholder test that always passes.\n    Can be removed or replaced as actual tests are added.\n    \"\"\"",
        "detail": "tests.test_main",
        "documentation": {}
    },
    {
        "label": "test_placeholder_true",
        "kind": 2,
        "importPath": "tests.test_main",
        "description": "tests.test_main",
        "peekOfCode": "def test_placeholder_true():\n    \"\"\"\n    A placeholder test that always passes.\n    Can be removed or replaced as actual tests are added.\n    \"\"\"\n    assert True is True",
        "detail": "tests.test_main",
        "documentation": {}
    }
]